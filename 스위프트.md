## chap.3 데이터 타입 기본

스위프트의 기본 데이터 타입이 모두 구조체를 기반으로 구현되어 있다는 점.

스위프트의 모든 데이터 타입 이름은 첫 글자가 대문자로 시작하는 **대문자 카멜케이스**를 사용합니다.

#### 3.1 Int와 UInt

정수 타입 Int는 + , -를 포함한 정수를 뜻함. 이 중에서 - 부호를 포함하지 않고 0을 포함한 양의 정수는 UInt로 표현. Int 와 UInt 타입의 최댓값과 최솟값은 각각 max 와 min 프로퍼티로 알아볼 수 있다. Int UInt 각각 8bit , 16bit , 32bit , 64bit -> Int8 , Int16 , Int32 , Int64. 데이터의 크기에 따라 타입이 분리되어 있음. 시스템 아키텍쳐에 따라 Int 와 UInt의 타입이 달라짐. 32비트면 Int32 가 Int타입 , 64비트면 Int64가 Int로. UInt도 마찬가지.

*tip* : Int 와 Uint 중 선택해서 사용하기

~~~swift
var integer: Int = -100
let unsignedInteger: UInt = 50 //UInt 에는 음수값을 할당 못해욘
print("Integer 값 : \(integer) , unsignedInterger 값 : \(unsignedInter)")
print("Int 최댓값 : \(Int.max), Int 최솟값 : \(Int.min)")
print("UInt 최댓값 : \(UInt.max), UInt 최솟값 : \(UInt.min)")

let largeInteger: Int64 = Int64.max
let smallUnsignedInteger: UInt8 = UInt8.max
print("Int64 최댓값 : \(largeInteger), UInt8 최댓값 : \(smallUnsignedInteger)")

let tooLarge: Int = Int.max + 1 //Int의 표현범위를 초과하므로 오류
let cannotBeNegetive: UInt = -5 //UInt는 음수가 될 수 없으므로 오류

integer = unsignedInteger // Int와 UInt는 다른 타입이어서 오류
integer = Int(unsignedInteger) //Int타입의 값을 할당해줘야함
~~~

~~~swift
let decimalInteger: Int = 28  //10진수
let binaryInteger: Int = 0b11100  //2진수
let octalInteger: Int = 0o34  //8진수
let hexadecimalInteger: Int = 0x1C  //16진수
~~~

#### 3.2 Bool

Bool은 불리언 타입이다. 참(true) 거짓(false)만 값으로 가진다.

~~~swift
let boolean: Bool = true
let iLoveYou: Bool = true
let isTimeUnlimited: Bool = false
print("시간은 무한합니까?: \(isTimeUnlimited)")
~~~

#### 3.3 Float & Double

Float 는 32bit

Double 은 64bit

잘못쓰면 런타임 에러가 발생

둘 중에 하나 선택해서 사용해야하는데 잘 모르는 상황이면 Double 사용을 권장함

#### 3.4 Character

말 그대로 문자를 의미함. 유니코드 9 문자를 사용하므로 영어는 물론, 유니코드에서 지원하는 모든 언어 및 특수기호 등을 사용할 수 있다. 특수문자나 한글도 사용 가능하지만 변수이름에는 보통 영어로만 쓰임

#### 3.5 String

Character와 마찬가지로 유니코드 9 을 사용하며 문자열이다.

#####3.5.1 특수문자

| 특수문자 | 설명                                           |
| -------- | ---------------------------------------------- |
| \n       | 줄바꿈 문자                                    |
| \\\      | 문자열 내에서 백슬래시를 표현하고자 할 때 사용 |
| \\"      | 문자열 내에서 큰따옴표를 표현하고자 할 때 사용 |
| \t       | 탭 문자, 키보드의 탭키를 눌렀을 때와 같은 효과 |
| \0       | 문자열이 끝났음을 알리는 null 문자             |

#### 3.6 Any , AnyObject 와 nil

Any 는 모든 데이터 타입을 사용할 수 있다는 뜻

AnyObject 는 Any보다는 조금 한정된 의미로 클래스의 인스턴스만 할당할 수 있다.

~~~swift
var someVar: Any = "Subin"
someVar = 50
someVar = 100.1
~~~

nil는 '없음'을 나타내는 스위프트의 키워드 이다.

변수또는 상수에 값이 들어있지 않고 비어있음을 나타내는 데 사용한다.



## chap.4 데이터 타입 고급

#### 4.1 데이터 타입 안심

스위프트 특징 중 안전성(safe)이 가장 뚜렷하게 나타나는 부분이다. 스위프트는 타입에 굉장히 민감하고 엄격하다. 다른 타입끼리의 데이터 교환은 꼭 타입캐스팅을 거쳐야한다.

#####4.1.1 데이터 타입 안심이란

데이터 타입을 안심하고 사용할 수 있는 언어이다. Int 타입 변수에 할당 하련느 값이 Character 타입이라면 컴파일 오류가 발생한다. 스위프트는 컴파일 오류는 알려준다. 이렇게 컴파일 시 타입을 확인하는 것을 타입 확인 이라고 한다.

#####4.1.2 타입 추론

특정 타입을 명시하지 않아도 컴파일러가 할당된 값을 기준으로 변수나 상수의 타입을 결정

let name = "KangSuBin" 이면 name의 타입을 String으로 결정

#### 4.2 타입 별칭 (잘 씀)

이미 존재하는 데이터 타입에 임의로 다른 이름(별칭)을 부여할 수 있다. 그 다음 기본 타입과 별칭 모두 사용할 수 있다.

~~~swift
typealias MyInt = Int
typealias YourInt = Int
typealias MyDouble = Double

let age: MyInt = 100
var year: YourInt = 2080

//MyInt랑 YourInt도 Int여서 같은 타입으로 취급
year = age

let month: Int = 7  //기존 Int 사용 가능
let percentage: MyDouble = 99.9  //별칭 사용
~~~

#### 4.3 튜플 (가끔 씀)

'지정된 데이터의 묶음'이라고 표현할 수 있다. C를 예로 들자면 구조체의 형태가 비슷함. 또한 파이썬의 튜플과도 비슷함.

~~~swift
//String , Int , Double 타입을 갖는 튜플
var person: (String, Int, Double) = ("Subin", 24, 163.9)

//인덱스를 통해서 값을 빼 올 수 있다.
print("이름: \(person.0), 나이: \(person.1), key: \(person.2)")
~~~

#### 4.4 컬렉션 타입 (많이 써요)

배열, 딕셔너리, 셋ㅌ 등이 있다

#####4.4.1 배열 (맨날 씀)

*Note.* 스위프트의 Array - C언어의 배열처럼 버퍼이다. 킹치만 C언어처럼 한 번 선언하면 크기가 고정되던 버퍼가 아니라 , 자동으로 버퍼의 크기를 조절해주므로 요소의 삽입 및 삭제가 자유롭다.

#####4.4.2 딕셔너리

Value값은 같아도 Key 값은 매번 달라야 함. 요소들이 순서 없이 키와 밸류의 쌍으로 구성되는 컬렉션 타입이다. isEmpty 프로퍼티를 통해 비어있는ㅈ ㅣ확인 가능. count 프로퍼티로 딕셔너리의 요소 개수를 확인할 수 있다.

특정 키의 해당하는 값을 제거하려면 removeValue(forKey:) 메서드를 사용. 키에 해당하는 값이 제거된 후 반환. 만약 Key가 없으면 nil를 반환 

#####4.4.3 세트

딕셔너리와 마찬가지로 순서가 없다. value가 다 달라서 hash가 가능하다. 각 요소가 유일한 값이어야 한다(값 중복이 존재하지 않는다)

#### 4.5 열거형

enum , 많이쓰임. 관련있는 것끼리 모아둠. 열거형 각 항목이 원시 값(Raw Value)이라는 형태로 실제 값을 가질 수도 있다. 또는 연관 값(Associated Values)을 사용하여 다른 언어에서 공용체라고 불리는 값의 묶음도 구현할 수 있다. 열거형과 switch 구문이 만나면 멋지게 활용할 수 있다.

*Tip.* 열거형과 옵셔널 - 옵셔널은 enum(열거형)으로 구현되어 있습니다.

#####4.5.1 기본 열거형

enum이라는 키워드로 선언함

~~~swift
enum school {
  case primary
  case elementary
  case middle
  case high
  case college
  case university
  case graduate
}
~~~

각 항목은 그 자체가 고유의 값이다. 항목이 여러 가지라서 나열하기 귀찮거나 어렵다면 한 줄에 표현할 수도 있다.

~~~swift
enum School{
  case primary, elementary, middle, high, college, university, graduate
}
~~~

#####4.5.2 원시 값

raw value, 유지보수할 때 좋음. 열거형의 각 항목은 자체로도 하나의 값이지만 항목의 원시 값도 가질 수 있습니다. 즉 , 특정 타입으로 지정된 값을 가질 수 있다는 뜻입니다.

#####4.5.3 연관 값

열거형 각 항목이 연관 값을 가지게되면, 기존 프로그래밍 언어의 공용체 형태를 띌 수도 있다. 열거형 내의 항목이 자신과 연관된 값을 가질 수 있다. 연관값은 각 항목 옆에 소괄호로 묶어 표현한다. 다른 항목이 연관 값을 갖는다고 모든 항목이 연관 값을 가질 필요는 없다.



##chap.5 연산자

*Note*. 띄어쓰기와 연산자 - 스위프트에서는 연산자 앞과 뒤 어디에 공백이 있는지 중요한 부분이다.

####5.1 연산자의 종류

##### 5.1.1 할당 연산자

| 연산자            | 부호  | 설명                                              |
| ----------------- | ----- | ------------------------------------------------- |
| 할당(대입) 연산자 | A = B | A에 B의 값을 할당. 서로 다른 데이터 타입이면 오류 |

##### 5.1.2 산술 연산자

| 연산자 | 부호  | 설명                       |
| ------ | ----- | -------------------------- |
| 더하기 | A + B | 더한 값 반환               |
| 빼기   | A - B | 뺀 값 반환                 |
| 곱하기 | A * B | 곱한 값 반환               |
| 나누기 | A / B | 나눈 값 반환               |
| 나머지 | A % B | A를 B로 나눈 나머지를 반환 |

##### 5.1.3 비교 연산자

| 연산자           | 부호    | 설명                                                |
| ---------------- | ------- | --------------------------------------------------- |
| 같다             | A == B  | Bool값 반환                                         |
| 크거나 같다      | A >= B  | Bool값 반환                                         |
| 작거나 같다      | A <= B  | Bool값 반환                                         |
| 크다             | A > B   | Bool값 반환                                         |
| 작다             | A < B   | Bool값 반환                                         |
| 같지 않다        | A != B  | Bool값 반환                                         |
| 참조가 같다      | A === B | 같은 인스턴스를 가리키는지 비교 후 Bool값 반환      |
| 참조가 같지 않다 | A !== B | 같지 않은 인스턴스를 가리키는지 비교 후 Bool값 반환 |
| 패턴 매치        | A ~= B  | 패턴이 매치되는지 확인 후 Bool값 반환               |

##### 5.1.4 삼항 조건 연산자

| 연산자           | 부호             | 설명                                         |
| ---------------- | ---------------- | -------------------------------------------- |
| 삼항 조건 연산자 | Question ? A : B | Question(Bool)이 참이면 A, 거짓이면 B를 반환 |

##### 5.1.5 범위 연산자 (반복문에 쓰임)

| 연산자             | 부호    | 설명                |
| ------------------ | ------- | ------------------- |
| 폐쇄 범위 연산자   | A … B   | A , B 포함          |
| 반폐쇄 범위 연산자 | A ..< B | A포함 B미포함       |
| 단방향 범위 연산자 | A ...   | A이상 모두 A포함    |
|                    | …A      | A이하 모두 A포함    |
|                    | ..<A    | A미만 모두. A미포함 |



##### 5.1.6 부울 연산자 (코딩테스트할 때 잘나옴)

| 연산자                | 표현   | 설명                 |
| --------------------- | ------ | -------------------- |
| NOT(부정) 비트 연산자 | !B     | B의 참,거짓을 반전함 |
| AND 비트 연산자       | A&&B   | A와 B AND연산        |
| OR 비트 연산자        | A\|\|B | A와 B OR 연산        |



##### 5.1.7 비트 연산자

| 연산자                          | 표현        | 설명                   |
| ------------------------------- | ----------- | ---------------------- |
| NOT(부정) 비트 연산자           | ~A          | A의 비트를 반전한 결과 |
| AND 비트 연산자                 | A&B         | A와 B비트 AND연산 각각 |
| OR 비트 연산자                  | A\|B        | A와 B비트 OR 연산      |
| XOR 비트 연산자                 | A^B         | A와 B비트 XOR 연산     |
| 비트 이동 연산자(시프트 연산자) | A>>B   A<<B | A비트를 B만큼 이동     |



##### 5.1.8 복합 할당 연산자 (너무길어요)

##### 5.1.9 오버플로 연산자 (&를 사용해요)

##### 5.1.10 기타 연산자

#### 5.2 사용자정의 연산자 (당장은 안써요)



## chap.6 흐름 제어

#### 6.1 조건문

guard 구문도 있음

#####6.1.1 if 구문

조건값은 꼭 Bool 타입 이어야 함.

~~~swift
let first: Int = 5
let second: Int = 7

if first>second {
  print("first > second")
} else if first<second {
  print("first < second")
} else {
  print("first == second")
}
//결과는 "first < second" 가 출력됨
~~~

##### 6.1.2 switch 구문

케이스를 모두 다 쓰면 defalut를 안써도 되는데 한개라도 덜 쓰면 defalut 써야됨. break 안써도됨 근데 쭉쭉 실행하려면 fallthrough라는 키워드 사용해야함

####6.2 반복문

do-while 구문은 repeat-while로 구현되어있다.

##### 6.2.1 for-in 구문

반복적인 데이터나 시퀀스를 다룰 때 많이 사용

##### 6.2.2 while 구문

특정 조건(Bool 타입)이 성립하는 한 블록 내부의 코드를 반복해서 실행

##### 6.2.3 repeat-while 구문

do-while 같은거

#### 6.3 구문 이름표

반복문 앞에 이름과 함께 콜론을 붙여 구문의 이름을 지정해주는 구문 이름표 사용.



## chap.7 함수

#### 7.1 함수와 메서드

구조체,클래스,열거형 등 특정 타입에 연관되어 사용하는 함수를 **메서드**.

모듈 전체에서 전역적으로 사용할 수 있는 함수를 그냥 **함수**. 둘다 함수 인거는 마찬가지

#### 7.2 함수의 정의와 호출

함수를 정의하는 키워드는 func 이다. 매개변수는 () 로 감싸준다. 반환 타입을 명시하기 전에 -> 를 사용하여 어떤 타입이 반환될 것인지 명시해줌. 반환을 위한 키워드는 다른 언어처럼 return 이다.

##### 7.2.1 기본적인 함수의 정의와 호출

```swift
func hello(name: String) -> String {
  return "Hello \(name)!"
}

let helloSubin: String = hello(name: "Subin")
print(helloSubin)  //Hello Subin!
```

*Note.* 매개변수와 전달인자 - hello(name:) 함수의 매개변수는 name 이고, 실제 전달받는 값 "Subin"이 전달인자이다.

##### 7.2.2 매개변수 Parameter

**매개변수가 없는 함수와 매개변수가 여러 개인 함수** 함수에 매개변수가 필요 없다면 매개변수 위치를 공란으로 비워둠

~~~swift
func helloWorld() -> String{
  return "Hello, World"
}

print(helloWorld())  //Hello, World

func sayHello(myName: String, yourName: String) -> String{
  return "Hello \(yourName)! I'm\(myName)"
}

print(sayHello(myName: "subin", youtName: "jenny"))  //Hello jenny! I'm subin
~~~

**매개변수 이름과 전달인자 레이블** 전달인자 레이블을 사용하려면 함수 정의에서 매개변수 이름 앞에 한 칸 띄운후 전달인자 레이블을 지정합니다. _ 와일드 카드

~~~swift
//from과 to라는 전달인자 레이블이 있으며
//myName과 name이라는 매개변수 이름이 있는 sayHello gkatn
func sayHello(from myName: String, to name: String) -> String{
  return "Hello \(name)! I'm \(myName)"
}

print(sayHello(from: "subin", to: "jenny"))  //Hello jenny! I'm subin
~~~

함수 내부에서는 전달인자 레이블을 사용할 수 없고. 함수 호출시에는 매개변수 이름을 사용할 수 없다.

전달인자 레이블을 사용하고 싶지 않다면 와일드 카드 식별자를 사용하면됨

**매개변수 기본값**

매개변수마다 기본값(defalut value)를 지정할 수 있다.

**가변 매개변수와 입출력 매개변수**

매개변수로 몇 개의 값이 들어올지 모를 때, 가변 매개변수를 사용할 수 있다. 가변 매개변수는 0개의 값을 받아올 수 있다. 들어온 인자 값은 배열처럼 사용할 수 있다. 함수마다 가변 매개변수는 하나만 가질 수 있다.

함수의 전달인자로 값을 전달할 때는 보통 값을 복사해서 전달. 값이 아닌 참조를 전달하려면 입출력 매개변수를 사용해야함. 참조는 inout 매개변수로 전달될 변수 또는 앞에 &를 붙여서 표현. 원래는 복사였는데 inout을 붙여서 참조로 바꿔버림. inout은 코드를 짤때 지양하는것이 좋음. 외부적으로 영향을 끼칠수도 있다.

#####7.2.3 반환 타입

함수는 특정 연산을 실행한 후 결괏값을 반환한다. 그러나 값의 반환이 굳이 필요하지 않은 함수도 있다. 만약 반환 값이 없는 함수라면 반환 타입을 '없음'을 의미하는 Void로 표기하거나 이 표현 조차 생략 가능. 즉 반환 타입이 Void이거나, 생략되어 있다면 반환 값이 없는 함수이다.

##### 7.2.4 데이터 타입으로서의 함수

스위프트의 함수는 일급 객체이므로 하나의 데이터 타입으로 사용할 수 있다. 각 함수는 매개변수 타입과 반환 타입으로 구성된 하나의 타입으로 사용할 수 있다는 뜻이다. 함수를 하나의 데이터 타입으로 나타내는 방법은 아래와 같다

~~~swift
func sayHello(name: String, time: Int) -> String {
  //...
}
~~~

sayHello 함수의 타입은(String, Int) -> String 이다.

~~~swift
func sayHelloToFriends(me: String, names: String...) -> String{
  //...
}
~~~

sayHelloToFriends 함수의 타입은 (String, String…) -> String 이다. 만약 매개변수나 반환값이 없다면 Void키워드를 사용하여 없음을 나타냄

~~~swift
func sayHelloWorld(){
  //...
}
~~~

sayHelloWorld 함수의 타입은 (Void) -> Void이다. Void는 빈 소괄호로 표현할 수 있다.

(Void) -> Void

() -> Void

() -> () 모두 같은 말이다.

#### 7.3 중첩 함수

함수안에 함수. 재귀함수가 아닌 함수안에 함수를 넣을수 있다.

#### 7.4 반환 값을 무시할 수 있는 함수

리턴이 있어도 되고 없어도 된다.



## chap.8 옵셔널

단어 뜻 그대로 '있을 수도, 없을 수도 있음'을 나타내는 표현. 옵셔널은 enum

#### 8.1 옵셔널 사용

옵셔널 변수,상수가 아니면 nil를 할당할 수 없다.

~~~swift
var myName: String = "Subin"
myName = nil  //오류
~~~

nil은 옵셔널로 선언된 곳에서만 사용할 수 있다. 옵셔널 변수,상수 등은 데이터 타입뒤에 ?(물음표)를 붙여 사용

~~~swift
var myName: String? = "subin"
print(myName)  //subin

myName = nil

print(myName)  //nil
~~~

#### 8.2 옵셔널 추출 (3가지가 있어유)

#####8.2.1 강제 추출

런타임 오류가 일어날 가능성이 가장 높음. 옵셔널 값 뒤에 !(느낌표)를 붙이면 값을 강제로 추출하여 반환. 강제 추출 시 옵셔널에 값이 없다면 즉 nil이라면 런타임 오류가 발생함. 사용을 지양

##### 8.2.2 옵셔널 바인딩

옵셔널에 값이 있는지 없는지 부터 확인함.

~~~swift
var myName: String? = "Subin"

//옵셔널 바인딩을 통한 name이라는 임시 상수 할당
if let name = myName{
  print("My name is \(name)")
} else {
  print("My name is nil")
}
//My name is Subin
~~~

#####8.2.3 암시적 추출 옵셔널 (Implicitly Unwrapped Optional)

때때로 nil을 할당하고 싶지만 옵셔널 바인딩으로 매번 값을 추출하기 귀찮거나 로직상 nil때문에 런타임 오류가 발생하지 않을 것 같다는 확신이 들 때 nil을 할당해줄 수 있는 옵셔널이 아닌 변수나 상수가 있으면 좋을 것 이다. 이때 사용하는게 암시적 추출 옵셔널 이다. 옵셔널을 표시하고자 할 때 ? 사용했지만 암시적 추출 옵셔널을 사용하려면 !를 쓰면 됨

~~~swift
var myName: String! = "subin"
print(myName)  //subin
myName = nil

//암시적 어쩌구도 옵셔널이어서 옵셔널 바인딩을 쓸수있음
if var name = myName {
  print("My name is \(name)")
} else {
  print("My name == nil")
}
//myName == nil

myName.isEmpty  //오류
~~~

옵셔널을 사용할 때는 강제추출, 암시적 어쩌구를 쓰는것 보다 옵셔널 바인딩, nil 병합 연산자를 비롯해 뒤에서 배울 옵셔널 체이닝 등의 방법을 사용하는 편이 훨씬 안전하다.

## chap.9 구조체와 클래스

구조체는 복사 , 클래스는 참조

#### 9.1 구조체

##### 9.1.1 구조체 정의

struct 키워드로 정의한다

*Note.* 구초제 명명법 - 구조체를 정의한다는것이 새로운 타입을 생성해주는 것과 마찬가지므로 대문자 카멜케이스를 사용하여 이름을 짓는다.

~~~swift
struct BasicInformation {
  var name: String
  var age: Int
}
~~~

##### 9.1.2 구조체 인스턴스의 생성 및 초기화

구조체 정의를 마친 후 인스턴스를 생성하고 초기화 하고자 할 때는 기본적으로 생성되는 멤버 와이즈 이니셜라이저를 사용. 초기화 안해주면 자동으로 생성됨. 인스턴스가 생성되고 초기화된 후 프로퍼티 값에 접근하고 싶다면 .(마침표)를 사용하면 됨.

~~~swift
//프로퍼티 이름(name, age)으로 자동 생성된 이니셜 라이저를 사용하여 구조체 생성
var subinInfo: BasicInformation = BasicInformation(name: "subin", age: 24)
subinInfo.age = 2
subinInfo.name = "suban"  //변경 가능
~~~

#### 9.2 클래스

스위프트 클래스는 부모클래스가 없더라도 상송 없이 단독으로 정의가 가능

##### 9.2.1 클래스 정의

클래스를 정의할 때는 class라는 키워드 사용

*Note.* 클래스 명명법 - 카멜케이스로

~~~swift
class Person{
  var height: Float = 0.0
  var weight: Float = 0.0
}
~~~

ㄴ Float타입인 height 와 weight 저장 프로퍼티가 있는 Person 클래스이다.

##### 9.2.2 클래스 인스턴스의 생성과 초기화

초기화 안하면 오류떠요

변수선언은 let이어도 바꿀수 있음. 근데 class 안이 let이면 값을 못바꿈

##### 9.2.3 클래스 인스턴스의 소멸

클래스 인스턴스는 참조 타입이므로 더는 참조할 필요가 없을 때 메모리에서 알아서 해제됨. 이 과정을 소멸이라고 하는데 소멸되기 직전 deinit이라는 메서드가 호출된다. deinit은 디이니셜라이저라고 부름. 클래스당 하나만 구현할 수 있음

#### 9.3 구조체와 클래스의 차이

* 같은점
  * 값을 저장하기 위해 프로퍼티를 정의할 수 있다
  * 기능 실행을 위해 메서드를 정의할 수 있다.
  * 서브스크립트 문법을 통해 구조체 또는 클래스가 갖는 값에 접근하도록 서브스크립트를 정의할 수 있다.
  * 초기화될 때의 상태를 지정하기 위해 이니셜라이저를 정의할 수 있다.
  * 초기구현과 더불어 새로운 기능 추가를 위해 익스텐션을 통해 확장할 수 있다
  * 특정 기능을 실행하기 위해 특정 프로토콜을 준수할 수 있다
* 다른점
  * 구조체는 상속할 수 없다
  * 타입캐스팅은 클래스의 인스턴스에서만 허용
  * 디이니셜라이저는 클래스의 인스턴스에서만 활용
  * 참조 횟수 계산은 클래스의 인스턴스에서만

##### 9.3.1 값 타입과 참조 타입

##### 9.3.2 스위프트의 기본 데이터 타입은 모두 구조체

array , dictionary , set

#### 9.4 구조체와 클래스 선택해서 사용하기

간단하면 struct

복잡하면 class



## chap.10 프로퍼티와 메서드

**프로퍼티** 는 클래스, 구조체 또는 열거형 등에 관련된 값을 뜻합니다. 프로퍼티는 클래스, 구조체, 열거형 등에 안에있는 값. **메서드** 는 특정 타입에 관련된 함수를 뜻합니다. 메서드는 함수.

#### 10.1 프로퍼티

프로퍼티(관련된 값)은 크게 **저장 프로퍼티, 연산 프로퍼티, 타입 프로퍼티** 로 나눌 수 있습니다. 저장 프로퍼티는 인스턴스의 변수, 또는 상수를 의미합니다. 연산 프로퍼티는 값을 저장한 것이 아니라 특정 연산을 실행한 결괏값을 의미합니다. 연산 프로퍼티는 클래스, 구조체, 열거형에 쓰일 수 있다. 저장 프로퍼티는 구조체와 클래스에서만 사용(저장 프로퍼티 - struct, class에서만) , (연산 프로퍼티 - struct, class, enum에서) 저장 프로퍼티와 연산 프로퍼티는 특정 타입의 인스턴스에 사용되는 것을 뜻하지만 특정 타입에 사용되는 프로퍼티도 존재. 이를 타입 프로퍼티라고 함.

기존 프로그래밍 언어에서 사용되던 인스턴스 변수는 저장 프로퍼티, 클래스 변수는 타입 프로퍼티로 구분지을 수 있음. (타입 프로퍼티 - class or struct 안에있는 static변수) 더불어, 프로퍼티의 값이 변하는 것을 감시하는 프로퍼티 감시자(property observer)도 있습니다. 프로퍼티 감시자 - willset, didset. 프로퍼티 감시자는 프로퍼티의 값이 변할 때 값의 변화에 따른 특정 액션을 실행. 프로퍼티 감시자는 저장 프로퍼티에 적용할 수 있으며 부모 클래스로부터 상속받을 수 있음.

##### 10.1.1 저장 프로퍼티

var , let으로 저장. 저장 프로퍼티를 정의할 때 프로퍼티 기본값을 지정할 수 있으며, 초기화할 때 초깃값을 지정해줄 수도 있다.

*Note.* 구조체와 클래스의 저장 프로퍼티 - 구조체의 저장 프로퍼티가 옵셔널이 아니더라도, 구조체는 저장 프로퍼티를 모두 포함하는 이니셜라이저를 자동으로 생성. 하지만 클래스의 저장 프로퍼티는 옵셔널이 아니라면 프로퍼티 기본값을 지정해주거나 사용자정의 이니셜라이저를 통해 반드시 초기화 해줘야함.  또 클래스 인스턴스의 상수(let) 프로퍼티는 인스턴스가 초기화(이니셜라이저)될때 한 번만 값을 할당할 수 있음. 자식클래스에서 이 초기화를 변경할 수 없음. 

구조체 : 프로퍼티에맞는 이니셜라이저를 자동으로 제공.

클래스 : 자동으로 생성되지 않아서 클래스에서의 저장 프로퍼티를 사용하는 일은 번거로움. 하지만 클래스의 저장 프로퍼티에 초깃값을 지정해주면 따로 사용자정의 이니셜라이저를 구현해줄 필요가 없음

인스턴스를 생성할 때 이니셜라이저를 통해 초깃값을 보내야 하는 이유는 프로퍼티가 옵셔널이 아닌 값으로 선언되어 있기 때문이다. 그러므로 인스턴스는 생성할 때 프로퍼티에 값이 꼭 있는 상태여야 한다. 그런데 저장 프로퍼티가 옵셔널이라면 값이 있어도되고, 없어도되기때문에 초기화는 의무가 아니다.

##### 10.1.2 지연 저장 프로퍼티

lazy. 인스턴스를 생성할 때 프로퍼티에 값이 필요 없다면 프로퍼티를 옵셔널로 선언해줄 수 있음. 그런데 그것과는 다른 용도로 필요할 때 값이 할당되는 **지연 저장 프로퍼티**가 있음. 지연 저장 프로퍼티는 호출이 있어야 값을 초기화하며, 이때 lazy키워드 사용. 지연 저장 프로퍼티를 잘 사용하면 불필요한 성능저하나 공간 낭비를 줄일 수 있음(연산 프로퍼티와 다른 점).

*Note.* 다중 스레드와 지연 저장 프로퍼티 - 다중 스레드 환경에서 지연 저장 프로퍼티에 동시다발적으로 접근할 때는 한 번만 초기화된다는 보장이 없습니다. 생성되지 않은 지연 저장 프로퍼티에 많은 스레드가 비슷한 시점에 접근한다면, 여러 번 초기화될 수 있습니다.

##### 10.1.3 연산 프로퍼티

연산하는 함수로 만들수 있는데 프로퍼티 사용해서 가독성을 높였음. 클래스, 구조체, 열거형에 연산 프로퍼티를 정의할 수 있음.

##### 10.1.4 프로퍼티 감시자

willset, didset

*Note.* 입출력 매개변수와 프로퍼티 감시자 - 만약 프로퍼티 감시자가 있는 프로퍼티를 함수의 입출력 매개변수의 전달인자로 전달한다면 항상 willSet과 didSet감시자를 호출합니다. 함수 내부에서 값이 변경되든 되지 않든 간에 함수가 종료되는 시점에 값을 다시 쓰기 때문이다.

##### 10.1.5 전역변수와 지역변수

앞서 설명한 연산 프로퍼티와 프로퍼티 감시자는 전역변수와 지역변수 모두에 사용할 수 있음. 우리가 변수라고 통칭했던 전역변수, 지역변수는 저장변수라고 할 수 있음. 그런데 전역변수나 지역변수를 연산변수로 구현할 수도 있으며, 프로퍼티 감시자를 구현할 수도 있음

##### 10.1.6 타입 프로퍼티

각각의 인스턴수가 아닌 타입 자체에 속하는 프로퍼티를 **타입 프로퍼티**라고 한다. C언어의 static과 유사. 타입 프로퍼티는 두 가지인데 저장 타입 프로퍼티(var,let)는 변수 또는 상수로 선언할 수 있으며, 연산 타입 프로퍼티는 변수로만 선언할 수 있다. 저장 타입 프로퍼티는 반드시 초깃값을 설정해야 하며 지연 연산 됨. 지연 연산 프로퍼티와는 조금 다르게 다중 스레드 환경이라고 하더라도 단 한 번만 초기화된다는 보장을 받음. 지연 연산 된다고 해서 lazy 키워드로 표시하지는 않음.

~~~swift
class AClass {
  // 저장 타입 프로퍼티
  static var typeProperty: Int = 0
  
  // 저장 인스턴스 프로퍼티
  var instanceProperty: Int = 0 {
    didSet {
      AClass.typeProperty = instanceProperty + 100
    }
  }
  
  // 많이 쓰면 안좋음. 생성하지 않아도 메모리에 올라감. side effects 발생 확률 올라감
  // 연산 타입 프로퍼티
  static var typeComputedProperty: Int {
    get {
      return typeProperty
    }
    set {
      typeProperty = newValue
    }
  }
}

AClass.typeProperty = 123

let classInstance: AClass = AClass()
classInstance.instanceProperty = 100

print(AClass.typeProperty) // 100
print(AClass.typeComputedProperty) // 200
~~~

##### 10.1.7 키 경로

당장은 몰라도됨. 서브스크립트할 때 배움. 참조위치 알고있다가 쓰는것.

#### 10.2 메서드

특정 타입에 관련된 함수를 뜻함.

##### 10.2.1 인스턴스 메서드

struct는 self. 프로퍼티 변경 불가능. mutating으로 바꿔야함

**self 프로퍼티**

자바의 this. 모든 인스턴스는 암시적으로 생성된 self 프로퍼티를 가짐. 자기 자신을 가리키는 프로퍼티. self 프로퍼티는 인스턴스를 더 명확히 지칭하고 싶을 때 사용.

##### 10.2.2 타입 메서드

전역 함수. 인스턴스 프로퍼티와 타입 프로퍼티가 있듯이 메서드에도 인스턴스 메서드와 타입 메서드가 있음. 타입 자체에 호출이 가능한 메서드를 타입 메서드라고 부름. 메서드 앞에 static 키워드를 사용하여 타입 메서드임을 나타내줌. 클래스의 타입 메서드는 static 키워드와 class 키워드를 사용할 수 있는데 static으로 정의하면 상속 후 메서드 재정의가 불가능 하고 class로 정의하면 상속 후 메서드 재정의가 가능하다.

## chap.11 인스턴스 생성 및 소멸

#### 11.1 인스턴스 생성

이니셜라이저를 정의하면 초기화 과정을 직접 구현할 수 있습니다.

##### 11.1.1 프로퍼티 기본값

옵셔널 저장 프로퍼티를 제외한 모든 저장 프로퍼티에 적절한 초깃값을 할당해야 합니다.

*Note.* 초기화와 프로퍼티 감시자 - 이니셜라이저를 통해 초깃값을 할당하거나, 프로퍼티 기본값을 통해 처음의 저장 프로퍼티가 초기화될 때는 프로퍼티 감시자 메서드가 호출되지 않습니다.

~~~swift
struct Area {
  var squareMeter: Double
  
  init() {
    squareMeter = 0.0 // squarMeter의 초깃값 할당
  }
}

let room: Area() = Area()
print(room.squareMeter) // 0.0
~~~

##### 11.1.2 이니셜라이저 매개변수

함수나 메서드를 정의할 때와 마찬가지로 이니셜라이저도 매개변수를 가질 수 있다. 즉, 인스턴스를 초기화하는 과정에 필요한 값을 전달받을 수 있다. 아래 코드에서 이니셜라이저 매개변수를 확인

~~~swift
struct Area {
  var squareMeter: Double
  
  init(fromPy py: Double) {	// 첫 번째 이니셜라이저
    squareMeter = py * 3.3058
  }
  
  init(fromSquareMeter squareMeter: Double) {	// 두 번째 이니셜라이저
    self.squareMeter = squareMeter
  }
  
  init(value: Double) {	// 세 번째 이니셜라이저
    squareMeter = value
  }
  
  init(_ value: Double) {	// 네 번째 이니셜라이저
    squareMeter = value
  }
}

let roomOne: Area = Area(fromePy: 15.0)
print(roomOne.squareMeter)  // 49.587

let roomTwo: Area = Area(fromSquareMeter: 33.06)
print(roomTwo.squareMeter)  // 33.06

let roomThree: Area = Area(value: 30.0)
let roomFour: Area = Area(55.0)

Area()  // 오류 발생!!
~~~

##### 11.1.3 옵셔널 프로퍼티 타입

초기화 과정에서 값을 지정해주기 어려운 경우 저장 프로퍼티를 옵셔널로 선언할 수 있다. 옵셔널로 선언한 저장 프로퍼티는 초기화 과정에서 값을 할당해주지 않는다면 자동으로 nil리 할당된다.

##### 11.1.4 상수 프로퍼티

한번선언한것을 바꾸지 않으려면 상수로 선언해야한다. 상수로 선언된 저장 프로퍼티는 인스턴스를 초기화하는 과정에서만 값을 할당할 수 있으며, 처음 할당된 이후로는 값을 변경할 수 없다.

*Note.* 상수 프로퍼티와 상속

#####11.1.5 기본 이니셜라이저와 멤버와이즈 이니셜라이저

##### 11.1.6 초기화 위임

##### 11.1.7 실패 가능한 이니셜라이저

##### 11.1.8 함수를 사용한 프로퍼티 기본값 설정

#### 11.2 인스턴스 소멸



## chap.12 접근제어

#### 12.1 접근제어란

##### 12.1.1 접근제어의 필요성

##### 12.1.2 모듈의 소스파일

#### 12.2 접근수준

##### 12.2.1 공개 접근수준, public

##### 12.2.2 개방 접근수준, open

##### 12.2.3 내부 접근수준, internal

##### 12.2.4 파일외부비공개 접근수준, fileprivate

##### 12.2.5 비공개 접근수준, private

#### 12.3 접근제어 구현

#### 12.4 접근제어 구현 참고사항

#### 12.5 private와 fileprivate

#### 12.6 읽기 전용 구현



## chap.13 클로저

함수형 프로그래밍을 접할때 꼭 필요한것. 잘못쓰면 복잡해지기 때문에 잘 써야함. 함수인데 변수로 쓰이기도하고 파라미터로 쓰이기도하는 익명함수(이름이 있을수도 있음). 클로저는 세 가지 형태가 있다.

	- 이름이 있으면서 어떤 값도 획득하지 않는 전역함수의 형태
	- 이름이 있으면서 다른 함수 내부의 값을 획득할 수 있는 중첩된 함수의 형태
	- 이름이 없고 주변 문맥에 따라 값을 획득할 수 있는 축약 문법으로 작성한 형태



## chap.14 옵셔널 체이닝과 빠른종료

#### 14.1 옵셔널 체이닝

옵셔널을 반복 사용하여 옵셔널이 자전거 체인처럼 서로 꼬리를 물고 있는 모양이기 때문에 옵셔널 체이닝이라고 부름. 자전거 체인에서 한 칸이라도 없거나 고장 나면 전체가 동작하지 않듯이 중첩된 옵셔널 중 하나라도 값이 존재하지 않는다면 결과적으로 nil를 반환함.

*Note.* 느낌표(!) - 물음표 대신에 느낌표를 사용할 수도 있는데 이는 옵셔널에서 값을 강제 추출하는 효과가 있다. 정말 100% nil이 아니라는 확신을 하더라도 사용을 지양하는 편이 좋다.

#### 14.2 빠른종료

빠른종료의 핵심 키워드는 guard입니다. guard는 if구문과 유사하게 Bool 타입의 값으로 동작하는 기능이다. if문과 다른점은 guard 구문은 항상 else가 뒤따라온다. 만약 guard 뒤에 따라오는 Bool 값이 false라면 else 블록 내부코드를 실행한다. 이때 else 구문의 블록 내부에는 꼭 자신보다 상위의 코드 블록을 종료하는 코드가 들어가게 된다. 현재 코드 블록을 종료할때는 return, break, continue, throw 등의 제어문 전환 명령을 사용합니다. 또는 fatalError() 와 같은 비반환 함수나 메서드를 호출할 수도 있습니다.

~~~swift
guard Bool타입값 else {
  예외사항 실행문
  제어문 전환 명령어(return,break,continue,throw)
}
~~~

if 구문에서 예외사항만을 처리하고 싶다면 guard 구문을 사용하는 것이 훨씬 간편하다.



## chap.15 맵, 필터, 리듀스

클로저 배우고!

#### 15.1 맵

#### 15.2 필터

#### 15.3 리듀스

#### 15.4 맵, 필터, 리듀스의 활용



## chap.16 모나드

#### 16.1 컨텍스트

#### 16.2 함수객체

#### 16.3 모나드



## chap.17 서브스크립트

#### 17.1 서브스크립트 문법

#### 17.2 서브스크립트 구현

#### 17.3 복수 서브스크립트



## chap.18 상속

상속은 클래스만 가능

#### 18.1 클래스 상속

#### 18.2 재정의

##### 18.2.1 메서드 재정의

##### 18.2.2 프로퍼티 재정의

##### 18.2.3 프로퍼티 감시자 재정의

##### 18.2.4 서브스크립트 재정의

##### 18.2.5 재정의 방지

#### 18.3 클래스의 이니셜라이저 - 상속과 재정의

##### 18.3.1 지정 이니셜라이저와 편의 이니셜라이저

##### 18.3.2 클래스의 초기화 위임

##### 18.3.3 2단계 초기화

##### 18.3.4 이니셜라이저 상속 및 재정의

##### 18.3.5 이니셜라이저 자동상속

##### 18.3.6 요구 이니셜라이저





